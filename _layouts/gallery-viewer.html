---
layout: default
body_class: gallery-page
---

<div class="gallery-viewer-page">
  <div class="gallery-header">
    <div class="gallery-header-content">
      <a href="{{ '/gallery/' | relative_url }}" class="btn btn-outline btn-back">
        ‚Üê Back
      </a>
      <div class="gallery-header-text">
        <h1>{{ page.title }}</h1>
        <p>{{ page.description }}</p>
      </div>
    </div>
  </div>
  
  <div class="gallery-viewer" id="galleryViewer">
    <!-- Source Panel -->
    <div class="gallery-panel source-panel" id="sourcePanel" data-panel="source">
      <div class="panel-collapse-handle" data-target="source" title="Expand Source">
        <span class="collapse-label">üìÑ Source</span>
      </div>
      <div class="panel-main">
        <div class="panel-header">
          <span>üìÑ Source: {{ page.source_file }}</span>
          <button class="panel-collapse-btn" data-target="source" title="Collapse panel">‚óÄ</button>
        </div>
        <div class="panel-content" id="sourceContent">
          <div class="loading-placeholder">Loading source...</div>
        </div>
      </div>
    </div>
    
    <!-- Resize Handle 1 -->
    <div class="resize-handle" data-resize="source-tree" title="Drag to resize">
      <div class="resize-grip"></div>
    </div>
    
    <!-- File Tree Panel -->
    <div class="gallery-panel tree-panel" id="treePanel" data-panel="tree">
      <div class="panel-collapse-handle" data-target="tree" title="Expand Output Files">
        <span class="collapse-label">üìÅ Files</span>
      </div>
      <div class="panel-main">
        <div class="panel-header">
          <button class="panel-collapse-btn" data-target="tree" title="Collapse panel">‚óÄ</button>
          <span>üìÅ Output Files</span>
          <button class="panel-collapse-btn" data-target="tree" title="Collapse panel">‚ñ∂</button>
        </div>
        <div class="panel-content">
          <div class="file-tree" id="fileTree">
            {{ content }}
          </div>
        </div>
      </div>
    </div>
    
    <!-- Resize Handle 2 -->
    <div class="resize-handle" data-resize="tree-output" title="Drag to resize">
      <div class="resize-grip"></div>
    </div>
    
    <!-- Output Panel -->
    <div class="gallery-panel output-panel" id="outputPanel" data-panel="output">
      <div class="panel-collapse-handle" data-target="output" title="Expand Output">
        <span class="collapse-label">üìÑ Output</span>
      </div>
      <div class="panel-main">
        <div class="panel-header">
          <button class="panel-collapse-btn" data-target="output" title="Collapse panel">‚óÄ</button>
          <span id="outputFileName">üìÑ Select a file to view</span>
        </div>
        <div class="panel-content" id="outputContent">
          <div class="loading-placeholder">
            Click a file in the tree to view its contents
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Gallery page data from front matter -->
<script>
window.galleryPageData = {
  sourceContentB64: "{{ page.source_content_b64 }}",
  sourceLanguage: "{{ page.source_language }}",
  sourceIsBinary: {{ page.source_is_binary | default: false }},
  sourceFileUrl: "{{ page.source_file_url }}",
  sourceFileName: "{{ page.source_file }}",
  filesBaseUrl: "{{ page.files_base_url }}"
};
</script>

<style>
.gallery-viewer-page {
  display: flex;
  flex-direction: column;
  height: calc(100vh - 64px);
  overflow: hidden;
}

.gallery-header {
  flex-shrink: 0;
  padding: var(--spacing-lg) var(--spacing-xl);
  background: var(--color-bg-light);
  border-bottom: 1px solid var(--color-border);
}

.gallery-header-content {
  display: flex;
  align-items: center;
  gap: var(--spacing-lg);
  max-width: 100%;
}

.btn-back {
  flex-shrink: 0;
  padding: var(--spacing-sm) var(--spacing-md);
}

.gallery-header-text h1 {
  font-size: 1.5rem;
  margin-bottom: var(--spacing-xs);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.gallery-header-text p {
  color: var(--color-text-muted);
  font-size: 0.875rem;
  margin: 0;
}

.gallery-viewer {
  flex: 1;
  display: flex;
  min-height: 0;
  overflow: hidden;
}

/* Panel base styles */
.gallery-panel {
  display: flex;
  position: relative;
  overflow: hidden;
  transition: flex-basis 0.3s ease, min-width 0.3s ease;
}

.gallery-panel .panel-main {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-width: 0;
  overflow: hidden;
}

/* Panel sizing - using flex-basis */
.source-panel { flex: 1 1 35%; min-width: 200px; }
.tree-panel { flex: 0 0 280px; min-width: 180px; max-width: 500px; }
.output-panel { flex: 1 1 35%; min-width: 200px; }

/* Collapsed panel state */
.gallery-panel.collapsed {
  flex: 0 0 32px !important;
  min-width: 32px !important;
  max-width: 32px !important;
}

.gallery-panel.collapsed .panel-main {
  display: none;
}

.gallery-panel.collapsed .panel-collapse-handle {
  display: flex;
}

/* Collapse handle (vertical bar when collapsed) */
.panel-collapse-handle {
  display: none;
  width: 32px;
  height: 100%;
  background: var(--color-surface);
  border-right: 1px solid var(--color-border);
  cursor: pointer;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  transition: background var(--transition-fast);
}

.panel-collapse-handle:hover {
  background: var(--color-surface-hover);
}

.collapse-label {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  transform: rotate(180deg);
  font-family: var(--font-heading);
  font-weight: 600;
  font-size: 0.75rem;
  color: var(--color-text-muted);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  padding: var(--spacing-md) 0;
  white-space: nowrap;
}

/* Panel header with collapse buttons */
.panel-header {
  flex-shrink: 0;
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-sm) var(--spacing-md);
  background: var(--color-surface);
  border-bottom: 1px solid var(--color-border);
  font-family: var(--font-heading);
  font-weight: 600;
  font-size: 0.75rem;
  color: var(--color-text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.panel-header span {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.panel-collapse-btn {
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 20px;
  height: 20px;
  padding: 0;
  background: transparent;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  color: var(--color-text-muted);
  font-size: 0.625rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.panel-collapse-btn:hover {
  background: var(--color-surface-hover);
  color: var(--color-text);
  border-color: var(--color-border-light);
}

/* Source panel: only right collapse button */
.source-panel .panel-header .panel-collapse-btn { margin-left: auto; }

/* Tree panel: both buttons */
.tree-panel .panel-header { justify-content: space-between; }
.tree-panel .panel-header span { text-align: center; }
.tree-panel .panel-header .panel-collapse-btn:first-child { order: -1; }

/* Output panel: only left collapse button */
.output-panel .panel-header .panel-collapse-btn { order: -1; }

.panel-content {
  flex: 1;
  overflow: auto;
  background: var(--color-bg);
}

/* Resize handles */
.resize-handle {
  flex-shrink: 0;
  width: 6px;
  background: var(--color-border);
  cursor: col-resize;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background var(--transition-fast);
}

.resize-handle:hover,
.resize-handle.active {
  background: var(--color-primary);
}

.resize-handle.disabled {
  cursor: default;
  background: var(--color-bg-light);
}

.resize-handle.disabled:hover {
  background: var(--color-bg-light);
}

.resize-handle.disabled .resize-grip {
  opacity: 0.2;
}

.resize-grip {
  width: 2px;
  height: 40px;
  background: var(--color-text-dim);
  border-radius: 1px;
  opacity: 0.5;
}

.resize-handle:hover .resize-grip,
.resize-handle.active .resize-grip {
  background: white;
  opacity: 0.8;
}

.resize-handle.disabled:hover .resize-grip {
  background: var(--color-text-dim);
  opacity: 0.2;
}

/* Code display */
.source-panel pre,
.output-panel pre {
  margin: 0;
  padding: var(--spacing-md);
  min-height: 100%;
  background: var(--color-bg) !important;
}

.file-tree {
  padding: var(--spacing-sm);
}

.tree-item {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--radius-sm);
  cursor: pointer;
  font-size: 0.8125rem;
  color: var(--color-text-muted);
  transition: all var(--transition-fast);
  user-select: none;
}

.tree-item:hover {
  background: var(--color-surface-hover);
  color: var(--color-text);
}

.tree-item.active {
  background: var(--color-primary);
  color: white;
}

.tree-item.folder {
  font-weight: 500;
  color: var(--color-text);
}

.tree-icon {
  flex-shrink: 0;
  font-size: 0.875rem;
}

.tree-name {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.tree-children {
  margin-left: var(--spacing-md);
}

.tree-children.collapsed {
  display: none;
}

.loading-placeholder {
  padding: var(--spacing-xl);
  color: var(--color-text-muted);
  text-align: center;
}

/* Responsive */
@media (max-width: 900px) {
  .gallery-viewer {
    flex-direction: column;
  }
  
  .gallery-panel {
    flex: 1 1 auto !important;
    min-width: 100% !important;
    max-width: 100% !important;
    min-height: 150px;
  }
  
  .gallery-panel.collapsed {
    flex: 0 0 32px !important;
    min-height: 32px !important;
  }
  
  .gallery-panel.collapsed .panel-collapse-handle {
    width: 100%;
    height: 32px;
    flex-direction: row;
    border-right: none;
    border-bottom: 1px solid var(--color-border);
  }
  
  .gallery-panel.collapsed .collapse-label {
    writing-mode: horizontal-tb;
    transform: none;
    padding: 0 var(--spacing-md);
  }
  
  .resize-handle {
    width: 100%;
    height: 6px;
    cursor: row-resize;
  }
  
  .resize-grip {
    width: 40px;
    height: 2px;
  }
  
  .tree-panel {
    max-width: none !important;
  }
}

@media (max-width: 768px) {
  .gallery-header-content {
    flex-direction: column;
    align-items: flex-start;
    gap: var(--spacing-sm);
  }
  
  .gallery-header-text h1 {
    font-size: 1.25rem;
  }
}

/* Prevent text selection during resize */
.gallery-viewer.resizing {
  user-select: none;
  cursor: col-resize;
}

.gallery-viewer.resizing * {
  cursor: col-resize !important;
}
</style>

<script>
(function() {
  // Panel collapse/expand functionality
  const viewer = document.getElementById('galleryViewer');
  const panels = {
    source: document.getElementById('sourcePanel'),
    tree: document.getElementById('treePanel'),
    output: document.getElementById('outputPanel')
  };
  const handles = {
    sourceTree: document.querySelector('[data-resize="source-tree"]'),
    treeOutput: document.querySelector('[data-resize="tree-output"]')
  };
  
  function getCollapsedCount() {
    return Object.values(panels).filter(p => p.classList.contains('collapsed')).length;
  }
  
  function isCollapsed(panelId) {
    return panels[panelId] && panels[panelId].classList.contains('collapsed');
  }
  
  function togglePanel(panelId) {
    const panel = panels[panelId];
    if (!panel) return;
    
    const wasCollapsed = panel.classList.contains('collapsed');
    
    if (wasCollapsed) {
      // Expanding - always allowed
      panel.classList.remove('collapsed');
    } else {
      // Collapsing - only if less than 2 are already collapsed
      if (getCollapsedCount() < 2) {
        panel.classList.add('collapsed');
      }
    }
    
    updateLayout();
    saveState();
  }
  
  function updateLayout() {
    const sourceCollapsed = isCollapsed('source');
    const treeCollapsed = isCollapsed('tree');
    const outputCollapsed = isCollapsed('output');
    
    // Update resize handle states (disabled instead of hidden)
    // When center panel is collapsed, keep one handle active for source‚Üîoutput resizing
    if (handles.sourceTree) {
      // Disable if source is collapsed, OR if tree is collapsed AND output is also collapsed
      // Keep active when only tree is collapsed (to resize source‚Üîoutput)
      const disabled = sourceCollapsed || (treeCollapsed && outputCollapsed);
      handles.sourceTree.classList.toggle('disabled', disabled);
      // Mark as spanning source-output when tree is collapsed
      handles.sourceTree.classList.toggle('spans-collapsed', treeCollapsed && !sourceCollapsed && !outputCollapsed);
    }
    if (handles.treeOutput) {
      // Disable if output is collapsed, OR if tree is collapsed (source-tree handle takes over)
      const disabled = outputCollapsed || treeCollapsed;
      handles.treeOutput.classList.toggle('disabled', disabled);
    }
    
    // Reset flex values for uncollapsed panels to fill space
    // Only reset if we don't have stored widths
    if (!panels.source.style.flex || sourceCollapsed) {
      panels.source.style.flex = sourceCollapsed ? '' : '1 1 auto';
    }
    if (!panels.tree.style.flex || treeCollapsed) {
      panels.tree.style.flex = treeCollapsed ? '' : '0 0 280px';
    }
    if (!panels.output.style.flex || outputCollapsed) {
      panels.output.style.flex = outputCollapsed ? '' : '1 1 auto';
    }
    
    // When panels are collapsed, ensure remaining panels expand
    // If source is collapsed, give more space to tree and output
    // If tree is collapsed, source and output share the space evenly
    // If output is collapsed, give more space to source and tree
    
    if (sourceCollapsed && !treeCollapsed && !outputCollapsed) {
      // Source collapsed: tree stays fixed, output expands
      panels.tree.style.flex = '0 0 280px';
      panels.output.style.flex = '1 1 auto';
    } else if (treeCollapsed && !sourceCollapsed && !outputCollapsed) {
      // Tree collapsed: source and output share space
      panels.source.style.flex = '1 1 50%';
      panels.output.style.flex = '1 1 50%';
    } else if (outputCollapsed && !sourceCollapsed && !treeCollapsed) {
      // Output collapsed: source expands, tree stays fixed
      panels.source.style.flex = '1 1 auto';
      panels.tree.style.flex = '0 0 280px';
    } else if (sourceCollapsed && treeCollapsed) {
      // Both source and tree collapsed: output takes all
      panels.output.style.flex = '1 1 auto';
    } else if (sourceCollapsed && outputCollapsed) {
      // Both source and output collapsed: tree takes all
      panels.tree.style.flex = '1 1 auto';
      panels.tree.style.maxWidth = 'none';
    } else if (treeCollapsed && outputCollapsed) {
      // Both tree and output collapsed: source takes all
      panels.source.style.flex = '1 1 auto';
    }
  }
  
  // Collapse button click handlers
  document.querySelectorAll('.panel-collapse-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      togglePanel(btn.dataset.target);
    });
  });
  
  // Collapsed handle click to expand
  document.querySelectorAll('.panel-collapse-handle').forEach(handle => {
    handle.addEventListener('click', () => {
      togglePanel(handle.dataset.target);
    });
  });
  
  // Resize functionality
  let isResizing = false;
  let currentHandle = null;
  let startX = 0;
  let startWidths = {};
  
  document.querySelectorAll('.resize-handle').forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
      // Don't allow resize if handle is disabled
      if (handle.classList.contains('disabled')) return;
      
      isResizing = true;
      currentHandle = handle;
      startX = e.clientX;
      
      const resizeType = handle.dataset.resize;
      const treeCollapsed = isCollapsed('tree');
      
      if (resizeType === 'source-tree') {
        startWidths.source = panels.source.offsetWidth;
        if (treeCollapsed) {
          // When tree is collapsed, this handle resizes source‚Üîoutput
          startWidths.output = panels.output.offsetWidth;
        } else {
          startWidths.tree = panels.tree.offsetWidth;
        }
      } else if (resizeType === 'tree-output') {
        startWidths.tree = panels.tree.offsetWidth;
        startWidths.output = panels.output.offsetWidth;
      }
      
      viewer.classList.add('resizing');
      handle.classList.add('active');
      
      e.preventDefault();
    });
  });
  
  document.addEventListener('mousemove', (e) => {
    if (!isResizing) return;
    
    const deltaX = e.clientX - startX;
    const resizeType = currentHandle.dataset.resize;
    const treeCollapsed = isCollapsed('tree');
    
    if (resizeType === 'source-tree') {
      if (treeCollapsed) {
        // Tree is collapsed - resize source‚Üîoutput directly
        const newSourceWidth = Math.max(200, startWidths.source + deltaX);
        const newOutputWidth = Math.max(200, startWidths.output - deltaX);
        
        panels.source.style.flex = `0 0 ${newSourceWidth}px`;
        panels.output.style.flex = `0 0 ${newOutputWidth}px`;
      } else {
        // Normal source‚Üîtree resize
        const newSourceWidth = Math.max(200, startWidths.source + deltaX);
        const newTreeWidth = Math.max(180, Math.min(500, startWidths.tree - deltaX));
        
        panels.source.style.flex = `0 0 ${newSourceWidth}px`;
        panels.tree.style.flex = `0 0 ${newTreeWidth}px`;
      }
    } else if (resizeType === 'tree-output') {
      const newTreeWidth = Math.max(180, Math.min(500, startWidths.tree + deltaX));
      const newOutputWidth = Math.max(200, startWidths.output - deltaX);
      
      panels.tree.style.flex = `0 0 ${newTreeWidth}px`;
      panels.output.style.flex = `0 0 ${newOutputWidth}px`;
    }
  });
  
  document.addEventListener('mouseup', () => {
    if (isResizing) {
      isResizing = false;
      viewer.classList.remove('resizing');
      if (currentHandle) {
        currentHandle.classList.remove('active');
      }
      currentHandle = null;
      saveState();
    }
  });
  
  // State persistence
  function saveState() {
    const state = {
      collapsed: {
        source: isCollapsed('source'),
        tree: isCollapsed('tree'),
        output: isCollapsed('output')
      },
      widths: {
        source: panels.source.style.flex,
        tree: panels.tree.style.flex,
        output: panels.output.style.flex
      }
    };
    try {
      localStorage.setItem('galleryViewerState', JSON.stringify(state));
    } catch (e) {}
  }
  
  function loadState() {
    try {
      const state = JSON.parse(localStorage.getItem('galleryViewerState'));
      if (state) {
        // Restore collapsed state (max 2)
        let collapsedCount = 0;
        Object.entries(state.collapsed || {}).forEach(([id, collapsed]) => {
          if (collapsed && collapsedCount < 2 && panels[id]) {
            panels[id].classList.add('collapsed');
            collapsedCount++;
          }
        });
        
        // Don't restore widths - let updateLayout handle it based on collapsed state
        updateLayout();
      }
    } catch (e) {}
  }
  
  // Initialize
  loadState();
  updateLayout();
  
  // Listen for layout updates from other scripts
  window.addEventListener('gallery-layout-update', function() {
    updateLayout();
  });
})();
</script>

<!-- Gallery content loading script -->
<script>
(function() {
  const data = window.galleryPageData;
  if (!data) return;
  
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  function renderMarkdown(text) {
    let html = escapeHtml(text);
    
    // Headers
    html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
    html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
    html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
    
    // Bold and italic
    html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
    
    // Code blocks
    html = html.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>');
    html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
    
    // Links
    html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
    
    // Lists
    html = html.replace(/^[\-\*] (.+)$/gm, '<li>$1</li>');
    html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
    
    // Tables
    html = html.replace(/^\|(.+)\|$/gm, function(match, content) {
      const cells = content.split('|').map(c => c.trim());
      const isHeader = cells.every(c => /^[-:]+$/.test(c));
      if (isHeader) return '';
      return '<tr>' + cells.map(c => '<td>' + c + '</td>').join('') + '</tr>';
    });
    html = html.replace(/(<tr>.*<\/tr>)/s, '<table class="md-table">$1</table>');
    
    // Paragraphs
    html = html.replace(/^(?!<[hupolta])(.+)$/gm, '<p>$1</p>');
    html = html.replace(/<p><\/p>/g, '');
    
    return html;
  }
  
  document.addEventListener('DOMContentLoaded', function() {
    // Check if there's only a single file - if so, collapse the tree panel
    const fileItems = document.querySelectorAll('.tree-item.file');
    if (fileItems.length === 1) {
      const treePanel = document.getElementById('treePanel');
      if (treePanel && !treePanel.classList.contains('collapsed')) {
        treePanel.classList.add('collapsed');
        // Trigger layout update via custom event
        window.dispatchEvent(new CustomEvent('gallery-layout-update'));
      }
    }
    
    // Set source content
    const sourcePanel = document.querySelector('.source-panel .panel-content');
    if (sourcePanel) {
      if (data.sourceIsBinary) {
        sourcePanel.innerHTML = 
          '<div class="binary-file-notice">' +
            '<div class="binary-icon">üì¶</div>' +
            '<div class="binary-text">Binary file cannot be displayed</div>' +
            '<a href="' + data.sourceFileUrl + '" download="' + data.sourceFileName + '" class="btn btn-primary download-btn">' +
              '‚¨á Download ' + data.sourceFileName +
            '</a>' +
          '</div>';
      } else if (data.sourceContentB64) {
        try {
          const sourceContent = atob(data.sourceContentB64);
          sourcePanel.innerHTML = '<pre class="line-numbers"><code class="language-' + data.sourceLanguage + '">' + escapeHtml(sourceContent) + '</code></pre>';
          if (window.Prism) {
            Prism.highlightAllUnder(sourcePanel);
          }
        } catch (e) {
          sourcePanel.innerHTML = '<div class="loading-placeholder">Failed to load source</div>';
        }
      }
    }
    
    // Handle file tree clicks
    document.querySelectorAll('.tree-item.file').forEach(function(el) {
      el.addEventListener('click', async function() {
        const path = this.dataset.path;
        const lang = this.dataset.lang;
        const fileType = this.dataset.filetype || 'text';
        const fileName = path.split('/').pop();
        
        // Update active state
        document.querySelectorAll('.tree-item.active').forEach(function(item) {
          item.classList.remove('active');
        });
        this.classList.add('active');
        
        // Update header
        document.getElementById('outputFileName').textContent = 'üìÑ ' + fileName;
        
        const outputContent = document.getElementById('outputContent');
        
        // Handle binary files
        if (fileType === 'binary') {
          outputContent.innerHTML = 
            '<div class="binary-file-notice">' +
              '<div class="binary-icon">üì¶</div>' +
              '<div class="binary-text">Binary file cannot be displayed</div>' +
              '<a href="' + path + '" download="' + fileName + '" class="btn btn-primary download-btn">' +
                '‚¨á Download ' + fileName +
              '</a>' +
            '</div>';
          return;
        }
        
        // Load file content
        try {
          const response = await fetch(path);
          if (!response.ok) throw new Error('Failed to load file');
          const content = await response.text();
          
          if (fileType === 'markdown') {
            outputContent.innerHTML = '<div class="markdown-rendered">' + renderMarkdown(content) + '</div>';
          } else {
            outputContent.innerHTML = '<pre class="line-numbers"><code class="language-' + lang + '">' + escapeHtml(content) + '</code></pre>';
            if (window.Prism) {
              Prism.highlightAllUnder(outputContent);
            }
          }
        } catch (error) {
          outputContent.innerHTML = '<div style="padding: 20px; color: var(--color-text-muted);">Failed to load file</div>';
        }
      });
    });
    
    // Auto-select first file
    const firstFile = document.querySelector('.tree-item.file');
    if (firstFile) {
      firstFile.click();
    }
  });
})();
</script>