using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Text.Json;
using System.Text.Json.Serialization;

{% if namespace %}
namespace {{ namespace }}
{
{% endif %}
{% set ind=4 if namespace else 0 %}
{% filter indent(width=ind, first=True) %}
/// <summary>
/// Represents an optional value wrapper that distinguishes between undefined, null, and a value.
/// Compatible with DotNext.Optional API.
/// </summary>
/// <typeparam name="T">The type of the value</typeparam>
public struct Option<T>
{
    private T? _value;
    private bool _isDefined;

    /// <summary>
    /// Gets a value indicating whether the optional value is defined (either null or a value).
    /// </summary>
    [JsonIgnore]
    public readonly bool IsDefined => _isDefined;

    /// <summary>
    /// Gets a value indicating whether the optional value is undefined (not set).
    /// </summary>
    [JsonIgnore]
    public readonly bool IsUndefined => !_isDefined;

    /// <summary>
    /// Gets a value indicating whether the optional value has a non-null value.
    /// </summary>
    [JsonIgnore]
    public readonly bool HasValue => _isDefined && _value != null;

    /// <summary>
    /// Gets a value indicating whether the optional value is null (but defined).
    /// </summary>
    [JsonIgnore]
    public readonly bool IsNull => _isDefined && _value == null;

    /// <summary>
    /// Gets whether the value has been explicitly set (either to null or a value).
    /// Alias for IsDefined for backward compatibility.
    /// </summary>
    [JsonIgnore]
    public readonly bool IsSet => _isDefined;

    /// <summary>
    /// Gets the underlying value. Throws if the value is undefined.
    /// </summary>
    [JsonIgnore]
    public readonly T? Value
    {
        get
        {
            if (!_isDefined)
                throw new InvalidOperationException("Optional value is not defined");
            return _value;
        }
    }

    /// <summary>
    /// Creates an undefined Option
    /// </summary>
    public Option()
    {
        _value = default;
        _isDefined = false;
    }

    /// <summary>
    /// Creates an Option with a value (which may be null)
    /// </summary>
    /// <param name="value">The value to wrap</param>
    public Option(T? value)
    {
        _value = value;
        _isDefined = true;
    }

    /// <summary>
    /// Implicitly converts a value to an Option
    /// </summary>
    public static implicit operator Option<T>(T? value)
    {
        return new Option<T>(value);
    }

    /// <summary>
    /// Explicitly converts an Option to its value
    /// </summary>
    public static explicit operator T?(Option<T> option)
    {
        return option._value;
    }

    /// <summary>
    /// Gets the value if defined, otherwise returns the default value
    /// </summary>
    public readonly T? ValueOrDefault => _isDefined ? _value : default;

    /// <summary>
    /// Gets the value if defined, otherwise returns the specified default value
    /// </summary>
    public readonly T Or(T defaultValue)
    {
        return _isDefined && _value != null ? _value : defaultValue;
    }

    /// <summary>
    /// Gets the value if defined, otherwise returns the default value
    /// </summary>
    public readonly T? GetValueOrDefault(T? defaultValue = default)
    {
        return _isDefined ? _value : defaultValue;
    }

    /// <summary>
    /// Tries to get the value if it is defined
    /// </summary>
    public readonly bool TryGet(out T? value)
    {
        value = _value;
        return _isDefined;
    }

    /// <summary>
    /// Returns a string representation of the Option
    /// </summary>
    public override readonly string ToString()
    {
        if (!_isDefined) return "<undefined>";
        if (_value == null) return "null";
        return _value.ToString() ?? string.Empty;
    }

    /// <summary>
    /// Checks equality with another Option
    /// </summary>
    public override readonly bool Equals(object? obj)
    {
        if (obj is not Option<T> other) return false;
        if (_isDefined != other._isDefined) return false;
        if (!_isDefined) return true; // Both undefined
        return EqualityComparer<T?>.Default.Equals(_value, other._value);
    }

    /// <summary>
    /// Gets the hash code
    /// </summary>
    public override readonly int GetHashCode()
    {
        if (!_isDefined) return 0;
        return HashCode.Combine(_isDefined, _value);
    }
}

/// <summary>
/// JSON converter for Option&lt;T&gt; that handles serialization and deserialization
/// </summary>
public class OptionJsonConverter<T> : JsonConverter<Option<T>>
{
    /// <inheritdoc/>
    public override Option<T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.Null)
        {
            return new Option<T>(default(T));
        }
        
        var value = JsonSerializer.Deserialize<T>(ref reader, options);
        return new Option<T>(value);
    }

    /// <inheritdoc/>
    public override void Write(Utf8JsonWriter writer, Option<T> value, JsonSerializerOptions options)
    {
        if (value.IsUndefined)
        {
            // Skip writing the property entirely if undefined
            return;
        }
        
        if (value.IsNull)
        {
            writer.WriteNullValue();
        }
        else
        {
            JsonSerializer.Serialize(writer, value.Value, options);
        }
    }
}
{% endfilter %}
{% if namespace %}
}
{% endif %}
