using System;
using System.Collections.Generic;
using NUnit.Framework;

{% if namespace %}
namespace {{ namespace }}
{
{% endif %}
{% set ind=4 if namespace else 0 %}
{% filter indent(width=ind, first=True) %}
/// <summary> Test class for {{ class_base_name }} </summary> 
[TestFixture]
public class {{ test_class_name }}
{
    private {{ class_base_name }} _instance;

    /// <summary> Constructor </summary>
    public {{ test_class_name }}()
    {
        _instance = CreateInstance();
    }

    /// <summary> Create instance of {{ class_base_name }} </summary>
    public {{ class_base_name }} CreateInstance()
    {
        var instance = new {{ class_base_name }}();
        {%- for field in fields %}
        {%- if not field.is_const %}
        instance.{{ field.field_name }} = {{ field.test_value }};
        {%- endif %}
        {%- endfor %}
        return instance;
    }

    /// <summary> Testing Equals and GetHashCode - positive case </summary>
    [Test]
    public void TestEqualsAndHashCode_PositiveCase()
    {
        var instance1 = CreateInstance();
        var instance2 = CreateInstance();
        
        // Test equality
        Assert.That(instance1.Equals(instance2), Is.True, "Two instances with same values should be equal");
        Assert.That(instance1 == instance2, Is.False, "Operator == should use reference equality");
        
        // Test hash codes
        Assert.That(instance1.GetHashCode(), Is.EqualTo(instance2.GetHashCode()), 
            "Equal instances should have equal hash codes");
    }

    /// <summary> Testing Equals and GetHashCode - negative case </summary>
    [Test]
    public void TestEqualsAndHashCode_NegativeCase()
    {
        var instance1 = CreateInstance();
        var instance2 = CreateInstance();
        
        {%- set ns = {'found': false, 'is_complex_non_nullable': false} %}
        {%- for field in fields if not field.is_const %}
        {%- if not ns.found %}
        {%- set _ = ns.update({'found': true}) %}
        // Modify {{ field.field_name }} and verify inequality
        {%- set base_type = field.field_type.rstrip('?') %}
        {%- if base_type == "string" %}
        instance2.{{ field.field_name }} = (instance2.{{ field.field_name }} ?? "test") + "_modified";
        {%- elif base_type in ["int", "long", "short", "byte", "sbyte", "uint", "ulong", "ushort"] %}
        instance2.{{ field.field_name }} = ({{ base_type }})({{ "(instance2." + field.field_name + " ?? 0)" if field.field_type.endswith("?") else "instance2." + field.field_name }} + 1);
        {%- elif base_type in ["float", "double", "decimal"] %}
        instance2.{{ field.field_name }} = {{ "(instance2." + field.field_name + " ?? 0)" if field.field_type.endswith("?") else "instance2." + field.field_name }} + 1.0{{ "f" if base_type == "float" else "m" if base_type == "decimal" else "" }};
        {%- elif base_type == "bool" %}
        instance2.{{ field.field_name }} = !{{ "(instance2." + field.field_name + " ?? false)" if field.field_type.endswith("?") else "instance2." + field.field_name }};
        {%- elif field.field_type.endswith("?") %}
        // For nullable complex types (including global:: types), set to null to make it different
        instance2.{{ field.field_name }} = null;
        {%- elif base_type.startswith("global::") and field.is_enum %}
        // For non-nullable enum, cast to int and increment
        instance2.{{ field.field_name }} = ({{ base_type }})((int)instance2.{{ field.field_name }} + 1);
        {%- else %}
        {%- set _ = ns.update({'is_complex_non_nullable': true}) %}
        {%- endif %}
        {%- if not ns.is_complex_non_nullable %}
        Assert.That(instance1.Equals(instance2), Is.False, 
            "Instances with different {{ field.field_name }} should not be equal");
        {%- endif %}
        {%- endif %}
        {%- endfor %}
        {%- if ns.is_complex_non_nullable %}
        // For non-nullable complex types (like unions), verify the positive case works correctly
        // since we cannot create a meaningfully different value without knowing the type internals
        Assert.Pass("Skipped negative test for complex non-nullable type - positive case validates Equals implementation");
        {%- endif %}
    }

    {%- for field in fields %}
    /// <summary> Testing property {{ field.field_name }}  </summary>
    [Test]
    public void Test{{ field.field_name | replace ('@','') | pascal }}Property()
    {
        var testValue = {{ field.test_value }};
        {%- if not field.is_const %}
        _instance.{{ field.field_name }} = testValue;
        {%- endif %}
        {%- if field.is_primitive %}
        {%- if field.field_type.startswith("List<") or field.field_type.startswith("Dictionary<") %}
        Assert.That(_instance.{{ field.field_name }}, Is.EquivalentTo(testValue));
        {%- else %}
        Assert.That(_instance.{{ field.field_name }}, Is.EqualTo(testValue));
        {%- endif %}
        {%- else %}
        Assert.That(_instance.{{ field.field_name }}, Is.EqualTo(testValue));
        {%- endif %}
    }
    {%- endfor %}
    {%- if avro_annotation %}
    /// <summary> Testing Avro serializer </summary>
    [Test]
    public void Test_ToByteArray_FromData_Avro()
    {
        var mediaType = "application/vnd.apache.avro+avro";
        var bytes = _instance.ToByteArray(mediaType);
        var newInstance = {{ class_base_name }}.FromData(bytes, mediaType);
        Assert.That(newInstance, Is.EqualTo(_instance));
    }
    {%- endif %}
    {%- if system_text_json_annotation or newtonsoft_json_annotation %}
    /// <summary> Testing JSON serializer </summary>
    [Test]
    public void Test_ToByteArray_FromData_Json()
    {
        var mediaType = "application/json";
        var bytes = _instance.ToByteArray(mediaType);
        var newInstance = {{ class_base_name }}.FromData(bytes, mediaType);
        Assert.That(newInstance, Is.EqualTo(_instance));
    }
    
    /// <summary> Testing FromData with various input types </summary>
    [Test]
    public void Test_FromData_EdgeCases()
    {
        // Test with null data
        var nullResult = {{ class_base_name }}.FromData(null, "application/json");
        Assert.That(nullResult, Is.Null);
        
        // Test with existing instance
        var existingInstance = {{ class_base_name }}.FromData(_instance, "application/json");
        Assert.That(existingInstance, Is.SameAs(_instance));
        
        // Test with null content type (should use JSON as fallback)
        var jsonBytes = _instance.ToByteArray("application/json");
        var defaultResult = {{ class_base_name }}.FromData(jsonBytes, "application/json");
        Assert.That(defaultResult, Is.EqualTo(_instance));
        
        // Test with BinaryData
        var binaryData = new System.BinaryData(jsonBytes);
        var binaryResult = {{ class_base_name }}.FromData(binaryData, "application/json");
        Assert.That(binaryResult, Is.EqualTo(_instance));
        
        // Test with Stream
        using var stream = new System.IO.MemoryStream(jsonBytes);
        var streamResult = {{ class_base_name }}.FromData(stream, "application/json");
        Assert.That(streamResult, Is.EqualTo(_instance));
    }
    
    /// <summary> Testing IsJsonMatch method </summary>
    [Test]
    public void Test_IsJsonMatch()
    {
        var jsonBytes = _instance.ToByteArray("application/json");
        var jsonString = System.Text.Encoding.UTF8.GetString(jsonBytes);
        var jsonDocument = System.Text.Json.JsonDocument.Parse(jsonString);
        Assert.That({{ class_base_name }}.IsJsonMatch(jsonDocument.RootElement), Is.True);
        
        // Test with invalid JSON structure
        var invalidJson = """{"invalidField": "value"}""";
        var invalidDocument = System.Text.Json.JsonDocument.Parse(invalidJson);
        Assert.That({{ class_base_name }}.IsJsonMatch(invalidDocument.RootElement), Is.False);
    }
    
    /// <summary> Testing ToByteArray with various content types </summary>
    [Test]
    public void Test_ToByteArray_EdgeCases()
    {
        // Test with gzip compression
        var gzipBytes = _instance.ToByteArray("application/json+gzip");
        Assert.That(gzipBytes, Is.Not.Null);
        Assert.That(gzipBytes.Length, Is.GreaterThan(0));
        
        // Test deserialization of gzipped data
        var gzipResult = {{ class_base_name }}.FromData(gzipBytes, "application/json+gzip");
        Assert.That(gzipResult, Is.EqualTo(_instance));
    }
    {%- endif %}
    {%- if system_xml_annotation %}
    /// <summary> Testing XML serializer </summary>
    [Test]
    public void Test_ToByteArray_FromData_Xml()
    {
        var mediaType = "application/xml";
        var bytes = _instance.ToByteArray(mediaType);
        var newInstance = {{ class_base_name }}.FromData(bytes, mediaType);
        Assert.That(newInstance, Is.EqualTo(_instance));
    }
    {%- endif %}
}
{% endfilter %}
{% if namespace %}
}
{% endif %}
